import json
import re
import sys
import tkinter as tk
from tkinter import filedialog

def normalize_phone_number(phone_raw):
    """
    Extracts digits from phone string.
    Returns formatted 'xxx-xxx-xxxx' if 10 digits found, else None.
    """
    digits = re.sub(r'\D', '', phone_raw)
    if len(digits) == 10:
        return f"{digits[:3]}-{digits[3:6]}-{digits[6:]}"
    return None

def is_valid_zip_code(zip_raw):
    """
    Checks if zip code string contains exactly 5 digits.
    """
    # strict validation: exactly 5 digits, no other characters allowed (after stripping whitespace)
    return bool(re.fullmatch(r'\d{5}', zip_raw.strip()))

def parse_line(line):
    """
    Parses a single line of input text.
    Returns a dictionary with keys: firstname, lastname, phonenumber, color, zipcode
    or None if parsing fails (format not recognized).
    """
    line = line.strip()
    if not line:
        return None
    
    parts = [p.strip() for p in line.split(',')]
    
    first_name = ""
    last_name = ""
    phone_number = ""
    zip_code = ""
    color = ""

    # Format 2 -> 4 parts
    if len(parts) == 4:
        # [Name, Color, Zip, Phone]
        # Strategy: Check if parts[2] looks like zip. And parts[1] looks like complete name separated by a space.
        
        if not is_valid_zip_code(parts[2]):
            return None

        name_parts = parts[0].rsplit(' ', 1)
        if len(name_parts) == 2:
            first_name = name_parts[0]
            last_name = name_parts[1]
        else:
            # If no space in name, it's invalid per "Firstname Lastname" structure requirement
            return None
        
        color = parts[1]
        zip_code = parts[2]
        phone_number = parts[3]

    # Format 1 or 3 -> 5 parts
    elif len(parts) == 5:
        # Format 1: Lastname, Firstname, (703)-742-0996, Blue, 10013
        # Format 3: Firstname, Lastname, 10013, 646 111 0101, Green
        
        # Strategy: Check if parts[2] is zip -> Format 3
        #           Check if parts[4] is zip -> Format 1
        
        is_p2_zip = is_valid_zip_code(parts[2])
        is_p4_zip = is_valid_zip_code(parts[4])
        
        if is_p2_zip and not is_p4_zip:
            # Format 3: Firstname, Lastname, Zip, Phone, Color
            first_name = parts[0]
            last_name = parts[1]
            zip_code = parts[2]
            phone_number = parts[3]
            color = parts[4]
            
        elif is_p4_zip:
            # Format 1: Lastname, Firstname, Phone, Color, Zip
            last_name = parts[0]
            first_name = parts[1]
            phone_number = parts[2]
            color = parts[3]
            zip_code = parts[4]
            
        else:
            return None

    else:
        # Has more than 5 parts or less than 4 parts, Unknown format
        return None

    return {
        "firstname": first_name.strip(),
        "lastname": last_name.strip(),
        "phonenumber": phone_number.strip(),
        "color": color.strip(),
        "zipcode": zip_code.strip()
    }

def main():
    input_file_path = None
    if len(sys.argv) > 1:
        input_file_path = sys.argv[1]
    else:
        # Use Tkinter to select file
        root = tk.Tk()
        root.withdraw() # Hide the main window
        input_file_path = filedialog.askopenfilename(
            title="Select Input File",
            filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")]
        )
        if not input_file_path:
            print("No file selected. Exiting.")
            return

    entries = []
    errors = []

    try:
        with open(input_file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
            
        for i, line in enumerate(lines):
            # Skip empty lines, in example line 4 is skipped
            if not line.strip():
                continue
                
            parsed_data = parse_line(line)
            
            if parsed_data:
                
                norm_phone = normalize_phone_number(parsed_data["phonenumber"])
                
                if norm_phone:
                    entry = {
                        "color": parsed_data["color"],
                        "firstname": parsed_data["firstname"],
                        "lastname": parsed_data["lastname"],
                        "phonenumber": norm_phone,
                        "zipcode": parsed_data["zipcode"]
                    }
                    entries.append(entry)
                else:
                    errors.append(i)
            else:
                errors.append(i)

        # Sorting by (lastname, firstname)
        entries.sort(key=lambda x: (x["lastname"], x["firstname"]))

        result = {
            "entries": entries,
            "errors": errors
        }

        # Output,indent 2 spaces
        with open(f"./outputs/result.json", "w", encoding='utf-8') as f:
            json.dump(result, f, indent=2, sort_keys=True)
            
        print("Processing complete. Check outputs/result.json")

    except FileNotFoundError:
        print(f"Error: {input_file_path} not found.")

if __name__ == "__main__":
    main()
